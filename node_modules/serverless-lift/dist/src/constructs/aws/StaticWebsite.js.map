{
  "version": 3,
  "sources": ["../../../../src/constructs/aws/StaticWebsite.ts"],
  "sourcesContent": ["import { Bucket } from \"@aws-cdk/aws-s3\";\nimport {\n    AllowedMethods,\n    CachePolicy,\n    Distribution,\n    FunctionEventType,\n    HttpVersion,\n    OriginAccessIdentity,\n    ViewerProtocolPolicy,\n} from \"@aws-cdk/aws-cloudfront\";\nimport * as cloudfront from \"@aws-cdk/aws-cloudfront\";\nimport type { Construct as CdkConstruct } from \"@aws-cdk/core\";\nimport { CfnOutput, Duration, RemovalPolicy } from \"@aws-cdk/core\";\nimport type { FromSchema } from \"json-schema-to-ts\";\nimport chalk from \"chalk\";\nimport { S3Origin } from \"@aws-cdk/aws-cloudfront-origins\";\nimport * as acm from \"@aws-cdk/aws-certificatemanager\";\nimport { flatten } from \"lodash\";\nimport type { ErrorResponse } from \"@aws-cdk/aws-cloudfront/lib/distribution\";\nimport type { AwsProvider } from \"@lift/providers\";\nimport { AwsConstruct } from \"@lift/constructs/abstracts\";\nimport type { ConstructCommands } from \"@lift/constructs\";\nimport { log } from \"../../utils/logger\";\nimport { s3Sync } from \"../../utils/s3-sync\";\nimport ServerlessError from \"../../utils/error\";\nimport { emptyBucket, invalidateCloudFrontCache } from \"../../classes/aws\";\nimport { redirectToMainDomain } from \"../../classes/cloudfrontFunctions\";\n\nconst STATIC_WEBSITE_DEFINITION = {\n    type: \"object\",\n    properties: {\n        type: { const: \"static-website\" },\n        path: { type: \"string\" },\n        domain: {\n            anyOf: [\n                { type: \"string\" },\n                {\n                    type: \"array\",\n                    items: { type: \"string\" },\n                },\n            ],\n        },\n        certificate: { type: \"string\" },\n        security: {\n            type: \"object\",\n            properties: {\n                allowIframe: { type: \"boolean\" },\n            },\n            additionalProperties: false,\n        },\n        errorPage: { type: \"string\" },\n        redirectToMainDomain: { type: \"boolean\" },\n    },\n    additionalProperties: false,\n    required: [\"path\"],\n} as const;\n\ntype Configuration = FromSchema<typeof STATIC_WEBSITE_DEFINITION>;\n\nexport class StaticWebsite extends AwsConstruct {\n    public static type = \"static-website\";\n    public static schema = STATIC_WEBSITE_DEFINITION;\n    public static commands: ConstructCommands = {\n        upload: {\n            usage: \"Upload files directly to S3 without going through a CloudFormation deployment.\",\n            handler: StaticWebsite.prototype.uploadWebsite,\n        },\n    };\n\n    private readonly distribution: Distribution;\n    private readonly domains: string[] | undefined;\n    private readonly bucketNameOutput: CfnOutput;\n    private readonly domainOutput: CfnOutput;\n    private readonly cnameOutput: CfnOutput;\n    private readonly distributionIdOutput: CfnOutput;\n\n    constructor(\n        scope: CdkConstruct,\n        private readonly id: string,\n        private readonly configuration: Configuration,\n        private readonly provider: AwsProvider\n    ) {\n        super(scope, id);\n\n        if (configuration.domain !== undefined && configuration.certificate === undefined) {\n            throw new ServerlessError(\n                `Invalid configuration for the static website '${id}': if a domain is configured, then a certificate ARN must be configured in the 'certificate' option.\\n` +\n                    \"See https://github.com/getlift/lift/blob/master/docs/static-website.md#custom-domain\",\n                \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n            );\n        }\n\n        const bucket = new Bucket(this, \"Bucket\", {\n            // For a static website, the content is code that should be versioned elsewhere\n            removalPolicy: RemovalPolicy.DESTROY,\n        });\n\n        const cloudFrontOAI = new OriginAccessIdentity(this, \"OriginAccessIdentity\", {\n            comment: `Identity that represents CloudFront for the ${id} static website.`,\n        });\n        bucket.grantRead(cloudFrontOAI);\n\n        // Cast the domains to an array\n        this.domains = configuration.domain !== undefined ? flatten([configuration.domain]) : undefined;\n        const certificate =\n            configuration.certificate !== undefined\n                ? acm.Certificate.fromCertificateArn(this, \"Certificate\", configuration.certificate)\n                : undefined;\n\n        const functionAssociations = [\n            {\n                function: this.createResponseFunction(),\n                eventType: FunctionEventType.VIEWER_RESPONSE,\n            },\n        ];\n\n        const requestFunction = this.createRequestFunction();\n\n        if (requestFunction !== null) {\n            functionAssociations.push({\n                function: requestFunction,\n                eventType: FunctionEventType.VIEWER_REQUEST,\n            });\n        }\n\n        this.distribution = new Distribution(this, \"CDN\", {\n            comment: `${provider.stackName} ${id} website CDN`,\n            // Send all page requests to index.html\n            defaultRootObject: \"index.html\",\n            defaultBehavior: {\n                // Origins are where CloudFront fetches content\n                origin: new S3Origin(bucket, {\n                    originAccessIdentity: cloudFrontOAI,\n                }),\n                allowedMethods: AllowedMethods.ALLOW_GET_HEAD_OPTIONS,\n                // Use the \"Managed-CachingOptimized\" policy\n                // See https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html#managed-cache-policies-list\n                cachePolicy: CachePolicy.CACHING_OPTIMIZED,\n                viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,\n                functionAssociations: functionAssociations,\n            },\n            errorResponses: [this.errorResponse()],\n            // Enable http2 transfer for better performances\n            httpVersion: HttpVersion.HTTP2,\n            certificate: certificate,\n            domainNames: this.domains,\n        });\n\n        // CloudFormation outputs\n        this.bucketNameOutput = new CfnOutput(this, \"BucketName\", {\n            description: \"Name of the bucket that stores the static website.\",\n            value: bucket.bucketName,\n        });\n        let websiteDomain: string = this.distribution.distributionDomainName;\n        if (configuration.domain !== undefined) {\n            // In case of multiple domains, we take the first one\n            websiteDomain = typeof configuration.domain === \"string\" ? configuration.domain : configuration.domain[0];\n        }\n        this.domainOutput = new CfnOutput(this, \"Domain\", {\n            description: \"Website domain name.\",\n            value: websiteDomain,\n        });\n        this.cnameOutput = new CfnOutput(this, \"CloudFrontCName\", {\n            description: \"CloudFront CNAME.\",\n            value: this.distribution.distributionDomainName,\n        });\n        this.distributionIdOutput = new CfnOutput(this, \"DistributionId\", {\n            description: \"ID of the CloudFront distribution.\",\n            value: this.distribution.distributionId,\n        });\n    }\n\n    variables(): Record<string, unknown> {\n        return {\n            cname: this.distribution.distributionDomainName,\n        };\n    }\n\n    outputs(): Record<string, () => Promise<string | undefined>> {\n        return {\n            url: () => this.getUrl(),\n            cname: () => this.getCName(),\n        };\n    }\n\n    async postDeploy(): Promise<void> {\n        await this.uploadWebsite();\n    }\n\n    async uploadWebsite(): Promise<void> {\n        log(`Deploying the static website '${this.id}'`);\n\n        const bucketName = await this.getBucketName();\n        if (bucketName === undefined) {\n            throw new ServerlessError(\n                `Could not find the bucket in which to deploy the '${this.id}' website: did you forget to run 'serverless deploy' first?`,\n                \"LIFT_MISSING_STACK_OUTPUT\"\n            );\n        }\n\n        log(`Uploading directory '${this.configuration.path}' to bucket '${bucketName}'`);\n        const { hasChanges } = await s3Sync({\n            aws: this.provider,\n            localPath: this.configuration.path,\n            bucketName,\n        });\n        if (hasChanges) {\n            await this.clearCDNCache();\n        }\n\n        const domain = await this.getDomain();\n        if (domain !== undefined) {\n            log(`Deployed ${chalk.green(`https://${domain}`)}`);\n        }\n    }\n\n    private async clearCDNCache(): Promise<void> {\n        const distributionId = await this.getDistributionId();\n        if (distributionId === undefined) {\n            return;\n        }\n        await invalidateCloudFrontCache(this.provider, distributionId);\n    }\n\n    async preRemove(): Promise<void> {\n        const bucketName = await this.getBucketName();\n        if (bucketName === undefined) {\n            // No bucket found => nothing to delete!\n            return;\n        }\n\n        log(\n            `Emptying S3 bucket '${bucketName}' for the '${this.id}' static website, else CloudFormation will fail (it cannot delete a non-empty bucket)`\n        );\n        await emptyBucket(this.provider, bucketName);\n    }\n\n    async getUrl(): Promise<string | undefined> {\n        const domain = await this.getDomain();\n        if (domain === undefined) {\n            return undefined;\n        }\n\n        return `https://${domain}`;\n    }\n\n    async getBucketName(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.bucketNameOutput);\n    }\n\n    async getDomain(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.domainOutput);\n    }\n\n    async getCName(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.cnameOutput);\n    }\n\n    async getDistributionId(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.distributionIdOutput);\n    }\n\n    private errorResponse(): ErrorResponse {\n        // Custom error page\n        if (this.configuration.errorPage !== undefined) {\n            let errorPath = this.configuration.errorPage;\n            if (errorPath.startsWith(\"./\") || errorPath.startsWith(\"../\")) {\n                throw new ServerlessError(\n                    `The 'errorPage' option of the '${this.id}' static website cannot start with './' or '../'. ` +\n                        `(it cannot be a relative path).`,\n                    \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n                );\n            }\n            if (!errorPath.startsWith(\"/\")) {\n                errorPath = `/${errorPath}`;\n            }\n\n            return {\n                httpStatus: 404,\n                ttl: Duration.seconds(0),\n                responseHttpStatus: 404,\n                responsePagePath: errorPath,\n            };\n        }\n\n        /**\n         * The default behavior is optimized for SPA: all unknown URLs are served\n         * by index.html so that routing can be done client-side.\n         */\n        return {\n            httpStatus: 404,\n            ttl: Duration.seconds(0),\n            responseHttpStatus: 200,\n            responsePagePath: \"/index.html\",\n        };\n    }\n\n    private createResponseFunction(): cloudfront.Function {\n        const securityHeaders: Record<string, { value: string }> = {\n            \"x-frame-options\": { value: \"SAMEORIGIN\" },\n            \"x-content-type-options\": { value: \"nosniff\" },\n            \"x-xss-protection\": { value: \"1; mode=block\" },\n            \"strict-transport-security\": { value: \"max-age=63072000\" },\n        };\n        if (this.configuration.security?.allowIframe === true) {\n            delete securityHeaders[\"x-frame-options\"];\n        }\n        const jsonHeaders = JSON.stringify(securityHeaders, undefined, 4);\n        /**\n         * CloudFront function that manipulates the HTTP responses to add security headers.\n         */\n        const code = `function handler(event) {\n    var response = event.response;\n    response.headers = Object.assign({}, ${jsonHeaders}, response.headers);\n    return response;\n}`;\n\n        return new cloudfront.Function(this, \"ResponseFunction\", {\n            functionName: `${this.provider.stackName}-${this.provider.region}-${this.id}-response`,\n            code: cloudfront.FunctionCode.fromInline(code),\n        });\n    }\n\n    private createRequestFunction(): cloudfront.Function | null {\n        let additionalCode = \"\";\n\n        if (this.configuration.redirectToMainDomain === true) {\n            additionalCode += redirectToMainDomain(this.domains);\n        }\n\n        if (additionalCode === \"\") {\n            return null;\n        }\n\n        const code = `function handler(event) {\n    var request = event.request;${additionalCode}\n    return request;\n}`;\n\n        return new cloudfront.Function(this, \"RequestFunction\", {\n            functionName: `${this.provider.stackName}-${this.provider.region}-${this.id}-request`,\n            code: cloudfront.FunctionCode.fromInline(code),\n        });\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
