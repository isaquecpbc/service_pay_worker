{
  "version": 3,
  "sources": ["../../../../src/constructs/aws/Queue.ts"],
  "sourcesContent": ["import { Queue as CdkQueue } from \"@aws-cdk/aws-sqs\";\nimport type { FromSchema } from \"json-schema-to-ts\";\nimport { Alarm, ComparisonOperator, Metric } from \"@aws-cdk/aws-cloudwatch\";\nimport { Subscription, SubscriptionProtocol, Topic } from \"@aws-cdk/aws-sns\";\nimport type { AlarmActionConfig } from \"@aws-cdk/aws-cloudwatch/lib/alarm-action\";\nimport type { Construct as CdkConstruct } from \"@aws-cdk/core\";\nimport { CfnOutput, Duration } from \"@aws-cdk/core\";\nimport chalk from \"chalk\";\nimport type { PurgeQueueRequest, SendMessageRequest } from \"aws-sdk/clients/sqs\";\nimport ora from \"ora\";\nimport { spawnSync } from \"child_process\";\nimport * as inquirer from \"inquirer\";\nimport type { AwsProvider } from \"@lift/providers\";\nimport { AwsConstruct } from \"@lift/constructs/abstracts\";\nimport type { ConstructCommands } from \"@lift/constructs\";\nimport { pollMessages, retryMessages } from \"./queue/sqs\";\nimport { sleep } from \"../../utils/sleep\";\nimport { PolicyStatement } from \"../../CloudFormation\";\nimport type { CliOptions } from \"../../types/serverless\";\nimport ServerlessError from \"../../utils/error\";\n\nconst QUEUE_DEFINITION = {\n    type: \"object\",\n    properties: {\n        type: { const: \"queue\" },\n        worker: {\n            type: \"object\",\n            properties: {\n                timeout: { type: \"number\" },\n            },\n            additionalProperties: true,\n        },\n        maxRetries: { type: \"number\" },\n        alarm: { type: \"string\" },\n        batchSize: {\n            type: \"number\",\n            minimum: 1,\n            maximum: 10,\n        },\n        fifo: { type: \"boolean\" },\n        delay: { type: \"number\" },\n    },\n    additionalProperties: false,\n    required: [\"worker\"],\n} as const;\ntype Configuration = FromSchema<typeof QUEUE_DEFINITION>;\n\nexport class Queue extends AwsConstruct {\n    public static type = \"queue\";\n    public static schema = QUEUE_DEFINITION;\n    public static commands: ConstructCommands = {\n        logs: {\n            usage: \"Output the logs of the queue's worker function\",\n            handler: Queue.prototype.displayLogs,\n            options: {\n                tail: {\n                    usage: \"Tail the log output\",\n                    shortcut: \"t\",\n                    type: \"boolean\",\n                },\n                startTime: {\n                    usage: \"Logs before this time will not be displayed. Default: `10m` (last 10 minutes logs only)\",\n                    type: \"string\",\n                },\n                filter: {\n                    usage: \"A filter pattern\",\n                    type: \"string\",\n                },\n                interval: {\n                    usage: \"Tail polling interval in milliseconds. Default: `1000`\",\n                    shortcut: \"i\",\n                    type: \"string\",\n                },\n            },\n        },\n        send: {\n            usage: \"Send a new message to the SQS queue\",\n            handler: Queue.prototype.sendMessage,\n            options: {\n                body: {\n                    usage: \"Body of the SQS message\",\n                    type: \"string\",\n                },\n                \"group-id\": {\n                    usage: \"This parameter applies only to FIFO (first-in-first-out) queues. The ID that specifies that a message belongs to a specific message group.\",\n                    type: \"string\",\n                },\n            },\n        },\n        failed: {\n            usage: \"List failed messages from the dead letter queue\",\n            handler: Queue.prototype.listDlq,\n        },\n        \"failed:purge\": {\n            usage: \"Purge failed messages from the dead letter queue\",\n            handler: Queue.prototype.purgeDlq,\n        },\n        \"failed:retry\": {\n            usage: \"Retry failed messages from the dead letter queue by moving them to the main queue\",\n            handler: Queue.prototype.retryDlq,\n        },\n    };\n\n    private readonly queue: CdkQueue;\n    private readonly queueArnOutput: CfnOutput;\n    private readonly queueUrlOutput: CfnOutput;\n    private readonly dlqUrlOutput: CfnOutput;\n\n    constructor(\n        scope: CdkConstruct,\n        private readonly id: string,\n        private readonly configuration: Configuration,\n        private readonly provider: AwsProvider\n    ) {\n        super(scope, id);\n\n        // This should be covered by the schema validation, but until it is enforced by default\n        // this is a very common error for users\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (configuration.worker === undefined) {\n            throw new ServerlessError(\n                `Invalid configuration in 'constructs.${this.id}': no 'worker' defined. Queue constructs require a 'worker' function to be defined.`,\n                \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n            );\n        }\n\n        // The default function timeout is 6 seconds in the Serverless Framework\n        const functionTimeout = configuration.worker.timeout ?? 6;\n\n        const maxRetries = configuration.maxRetries ?? 3;\n\n        let delay = undefined;\n        if (configuration.delay !== undefined) {\n            if (configuration.delay < 0 || configuration.delay > 900) {\n                throw new ServerlessError(\n                    `Invalid configuration in 'constructs.${this.id}': 'delay' must be between 0 and 900, '${configuration.delay}' given.`,\n                    \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n                );\n            }\n\n            delay = Duration.seconds(configuration.delay);\n        }\n\n        const baseName = `${this.provider.stackName}-${id}`;\n\n        const dlq = new CdkQueue(this, \"Dlq\", {\n            queueName: configuration.fifo === true ? `${baseName}-dlq.fifo` : `${baseName}-dlq`,\n            // 14 days is the maximum, we want to keep these messages for as long as possible\n            retentionPeriod: Duration.days(14),\n            fifo: configuration.fifo,\n        });\n\n        this.queue = new CdkQueue(this, \"Queue\", {\n            queueName: configuration.fifo === true ? `${baseName}.fifo` : `${baseName}`,\n            // This should be 6 times the lambda function's timeout\n            // See https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html\n            visibilityTimeout: Duration.seconds(functionTimeout * 6),\n            deadLetterQueue: {\n                maxReceiveCount: maxRetries,\n                queue: dlq,\n            },\n            fifo: configuration.fifo,\n            deliveryDelay: delay,\n            contentBasedDeduplication: configuration.fifo,\n        });\n\n        const alarmEmail = configuration.alarm;\n        if (alarmEmail !== undefined) {\n            const alarmTopic = new Topic(this, \"AlarmTopic\", {\n                topicName: `${this.provider.stackName}-${id}-dlq-alarm-topic`,\n                displayName: `[Alert][${id}] There are failed jobs in the dead letter queue.`,\n            });\n            new Subscription(this, \"AlarmTopicSubscription\", {\n                topic: alarmTopic,\n                protocol: SubscriptionProtocol.EMAIL,\n                endpoint: alarmEmail,\n            });\n\n            const alarm = new Alarm(this, \"Alarm\", {\n                alarmName: `${this.provider.stackName}-${id}-dlq-alarm`,\n                alarmDescription: \"Alert triggered when there are failed jobs in the dead letter queue.\",\n                metric: new Metric({\n                    namespace: \"AWS/SQS\",\n                    metricName: \"ApproximateNumberOfMessagesVisible\",\n                    dimensions: {\n                        QueueName: dlq.queueName,\n                    },\n                    statistic: \"Sum\",\n                    period: Duration.minutes(1),\n                }),\n                evaluationPeriods: 1,\n                // Alert as soon as we have 1 message in the DLQ\n                threshold: 0,\n                comparisonOperator: ComparisonOperator.GREATER_THAN_THRESHOLD,\n            });\n            alarm.addAlarmAction({\n                bind(): AlarmActionConfig {\n                    return { alarmActionArn: alarmTopic.topicArn };\n                },\n            });\n        }\n\n        // CloudFormation outputs\n        this.queueArnOutput = new CfnOutput(this, \"QueueArn\", {\n            description: `ARN of the \"${id}\" SQS queue.`,\n            value: this.queue.queueArn,\n        });\n        this.queueUrlOutput = new CfnOutput(this, \"QueueUrl\", {\n            description: `URL of the \"${id}\" SQS queue.`,\n            value: this.queue.queueUrl,\n        });\n        this.dlqUrlOutput = new CfnOutput(this, \"DlqUrl\", {\n            description: `URL of the \"${id}\" SQS dead letter queue.`,\n            value: dlq.queueUrl,\n        });\n\n        this.appendFunctions();\n    }\n\n    outputs(): Record<string, () => Promise<string | undefined>> {\n        return {\n            queueUrl: () => this.getQueueUrl(),\n        };\n    }\n\n    variables(): Record<string, unknown> {\n        return {\n            queueUrl: this.queue.queueUrl,\n            queueArn: this.queue.queueArn,\n        };\n    }\n\n    permissions(): PolicyStatement[] {\n        return [new PolicyStatement(\"sqs:SendMessage\", [this.queue.queueArn])];\n    }\n\n    private appendFunctions(): void {\n        // The default batch size is 1\n        const batchSize = this.configuration.batchSize ?? 1;\n\n        // Override events for the worker\n        this.configuration.worker.events = [\n            // Subscribe the worker to the SQS queue\n            {\n                sqs: {\n                    arn: this.queue.queueArn,\n                    batchSize: batchSize,\n                    // TODO add setting\n                    maximumBatchingWindow: this.queue.fifo ? undefined : 60,\n                },\n            },\n        ];\n        this.provider.addFunction(`${this.id}Worker`, this.configuration.worker);\n    }\n\n    private async getQueueUrl(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.queueUrlOutput);\n    }\n\n    async getDlqUrl(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.dlqUrlOutput);\n    }\n\n    async listDlq(): Promise<void> {\n        const dlqUrl = await this.getDlqUrl();\n        if (dlqUrl === undefined) {\n            console.log(\n                chalk.red(\n                    'Could not find the dead letter queue in the deployed stack. Try running \"serverless deploy\" first?'\n                )\n            );\n\n            return;\n        }\n        const progress = ora(\"Polling failed messages from the dead letter queue\").start();\n        const messages = await pollMessages({\n            aws: this.provider,\n            queueUrl: dlqUrl,\n            progressCallback: (numberOfMessagesFound) => {\n                progress.text = `Polling failed messages from the dead letter queue (${numberOfMessagesFound} found)`;\n            },\n        });\n        if (messages.length === 0) {\n            progress.stopAndPersist({\n                symbol: \"\uD83D\uDC4C\",\n                text: \"No failed messages found in the dead letter queue\",\n            });\n\n            return;\n        }\n        progress.warn(`${messages.length} messages found in the dead letter queue:`);\n        for (const message of messages) {\n            console.log(chalk.yellow(`Message #${message.MessageId ?? \"?\"}`));\n            console.log(this.formatMessageBody(message.Body ?? \"\"));\n            console.log();\n        }\n        const retryCommand = chalk.bold(`serverless ${this.id}:failed:retry`);\n        const purgeCommand = chalk.bold(`serverless ${this.id}:failed:purge`);\n        console.log(`Run ${retryCommand} to retry all messages, or ${purgeCommand} to delete those messages forever.`);\n    }\n\n    async purgeDlq(): Promise<void> {\n        const dlqUrl = await this.getDlqUrl();\n        if (dlqUrl === undefined) {\n            console.log(\n                chalk.red(\n                    'Could not find the dead letter queue in the deployed stack. Try running \"serverless deploy\" first?'\n                )\n            );\n\n            return;\n        }\n        const progress = ora(\"Purging the dead letter queue of failed messages\").start();\n        await this.provider.request<PurgeQueueRequest, void>(\"SQS\", \"purgeQueue\", {\n            QueueUrl: dlqUrl,\n        });\n        /**\n         * Sometimes messages are still returned after the purge is issued.\n         * For a less confusing experience, we wait 500ms so that if the user re-runs `sls queue:failed` there\n         * are less chances that deleted messages show up again.\n         */\n        await sleep(500);\n        progress.succeed(\"The dead letter queue has been purged, failed messages are gone \uD83D\uDE48\");\n    }\n\n    async retryDlq(): Promise<void> {\n        const queueUrl = await this.getQueueUrl();\n        const dlqUrl = await this.getDlqUrl();\n        if (queueUrl === undefined || dlqUrl === undefined) {\n            console.log(\n                chalk.red('Could not find the queue in the deployed stack. Try running \"serverless deploy\" first?')\n            );\n\n            return;\n        }\n        const progress = ora(\"Moving failed messages from DLQ to the main queue to be retried\").start();\n        let shouldContinue = true;\n        let totalMessagesToRetry = 0;\n        let totalMessagesRetried = 0;\n        do {\n            const messages = await pollMessages({\n                aws: this.provider,\n                queueUrl: dlqUrl,\n                /**\n                 * Since we intend on deleting the messages, we'll reserve them for 10 seconds\n                 * That avoids having those message reappear in the `do` loop, because SQS sometimes\n                 * takes a while to actually delete messages.\n                 */\n                visibilityTimeout: 10,\n            });\n            totalMessagesToRetry += messages.length;\n            progress.text = `Moving failed messages from DLQ to the main queue to be retried (${totalMessagesRetried}/${totalMessagesToRetry})`;\n\n            const result = await retryMessages(this.provider, queueUrl, dlqUrl, messages);\n            totalMessagesRetried += result.numberOfMessagesRetried;\n            progress.text = `Moving failed messages from DLQ to the main queue to be retried (${totalMessagesRetried}/${totalMessagesToRetry})`;\n\n            // Stop if we have any failure (that simplifies the flow for now)\n            if (result.numberOfMessagesRetriedButNotDeleted > 0 || result.numberOfMessagesNotRetried > 0) {\n                progress.fail(`There were some errors:`);\n                if (totalMessagesRetried > 0) {\n                    console.log(\n                        `${totalMessagesRetried} failed messages have been successfully moved to the main queue to be retried.`\n                    );\n                }\n                if (result.numberOfMessagesNotRetried > 0) {\n                    console.log(\n                        `${result.numberOfMessagesNotRetried} failed messages could not be retried (for some unknown reason SQS refused to move them). These messages are still in the dead letter queue. Maybe try again?`\n                    );\n                }\n                if (result.numberOfMessagesRetriedButNotDeleted > 0) {\n                    console.log(\n                        `${result.numberOfMessagesRetriedButNotDeleted} failed messages were moved to the main queue, but were not successfully deleted from the dead letter queue. That means that these messages will be retried in the main queue, but they will also still be present in the dead letter queue.`\n                    );\n                }\n                console.log(\n                    \"Stopping now because of the error above. Not all messages have been retried, run the command again to continue.\"\n                );\n\n                return;\n            }\n\n            shouldContinue = result.numberOfMessagesRetried > 0;\n        } while (shouldContinue);\n\n        if (totalMessagesToRetry === 0) {\n            progress.stopAndPersist({\n                symbol: \"\uD83D\uDC4C\",\n                text: \"No failed messages found in the dead letter queue\",\n            });\n\n            return;\n        }\n        progress.succeed(`${totalMessagesRetried} failed message(s) moved to the main queue to be retried \uD83D\uDCAA`);\n    }\n\n    async sendMessage(options: CliOptions): Promise<void> {\n        const queueUrl = await this.getQueueUrl();\n        if (queueUrl === undefined) {\n            console.log(\n                chalk.red(\"Could not find the queue in the deployed stack. Try running 'serverless deploy' first?\")\n            );\n\n            return;\n        }\n\n        if (this.configuration.fifo === true && typeof options[\"group-id\"] !== \"string\") {\n            throw new ServerlessError(\n                `The '${this.id}' queue is a FIFO queue. You must set the SQS message group ID via the '--group-id' option.`,\n                \"LIFT_MISSING_CLI_OPTION\"\n            );\n        }\n\n        const body = typeof options.body === \"string\" ? options.body : await this.askMessageBody();\n\n        const params: SendMessageRequest = {\n            QueueUrl: queueUrl,\n            MessageBody: body,\n        };\n        if (this.configuration.fifo === true) {\n            // Type validated above\n            params.MessageGroupId = options[\"group-id\"] as string;\n        }\n\n        await this.provider.request<SendMessageRequest, never>(\"SQS\", \"sendMessage\", params);\n    }\n\n    displayLogs(options: CliOptions): void {\n        const args = [\"logs\", \"--function\", `${this.id}Worker`];\n        for (const [option, value] of Object.entries(options)) {\n            args.push(option.length === 1 ? `-${option}` : `--${option}`);\n            if (typeof value === \"string\") {\n                args.push(value);\n            }\n        }\n        console.log(chalk.gray(`serverless ${args.join(\" \")}`));\n        args.unshift(process.argv[1]);\n        spawnSync(process.argv[0], args, {\n            cwd: process.cwd(),\n            stdio: \"inherit\",\n        });\n    }\n\n    private formatMessageBody(body: string): string {\n        try {\n            // If it's valid JSON, we'll format it nicely\n            const data = JSON.parse(body) as unknown;\n\n            return JSON.stringify(data, null, 2);\n        } catch (e) {\n            // If it's not valid JSON, we'll print the body as-is\n            return body;\n        }\n    }\n\n    private async askMessageBody(): Promise<string> {\n        const responses = await inquirer.prompt({\n            message: \"What is the body of the SQS message to send (can be JSON or any string)\",\n            type: \"editor\",\n            name: \"body\",\n            validate: (input: string) => {\n                return input.length > 0 ? true : \"The message body cannot be empty\";\n            },\n        });\n\n        return (responses.body as string).trim();\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
